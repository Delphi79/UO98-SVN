using System;
using System.Collections.Generic;
using System.Diagnostics;
using Irony.Ast;
using Microsoft.VisualStudio.Text;
using Irony.Parsing;

namespace JoinUO.UOSL.Package.MEF
{
    /// <summary>
    /// A proxy implementation of a syntax tree node. 
    /// </summary>
    /// <remarks>Implementation of all properties/methods 
    /// for the INode interface are redirected to underlying 'real' syntax tree node generated by the 
    /// parser. Implements additional methods/properties necessary for designer
    /// </remarks>
    [DebuggerDisplay("{astnode.AsString} {snapshotSpan}")]
    class Node : IDisposable
    {
        public NodeProvider Provider { get; private set; }
        public AstNode astnode { get; private set; }
        private SnapshotSpan snapshotSpan;
        private SnapshotSpan extensionSpan;
        private List<Node> children = new List<Node>();

        /// <summary>
        /// Creates the designer (proxy) node over the real syntax node passed in as a parameter
        /// Also recursively creates child nodes for all 'real' node children
        /// </summary>
        /// <param name="parent"></param>
        /// <param name="snapshot"></param>
        /// <param name="node"></param>
        public Node(NodeProvider provider, Node parent, ITextSnapshot snapshot, AstNode node) : this(provider, snapshot, node.Location, node.Span.Length)
        {
            Parent = parent;
            this.astnode = node;

            foreach (AstNode child in node.ChildNodes)
                if (child != null)
                    children.Add(new Node(provider, this, snapshot, child));
        }

        /// <summary>
        /// Adds a "nodeless" node, primarily intended to denote comments.
        /// </summary>
        public Node(NodeProvider provider, Node parent, ITextSnapshot snapshot, Token token): this(provider, snapshot, token.Location, token.Length)
        {
        }

        /// <summary>
        /// This does the actual node construction
        /// </summary>
        private Node(NodeProvider provider, ITextSnapshot snapshot, SourceLocation location, int length)
        {
            this.Provider = provider;

            snapshotSpan = new SnapshotSpan(snapshot, location.Position, length);
            int offset = 0;

            ITextSnapshotLine line = snapshot.GetLineFromPosition(location.Position);

            // if the Value list is not empty, expand the snapshotSpan
            // to include leading whitespaces, so that when a user
            // types smth in this space he will get the dropdown
            for (; location.Position - offset > line.Extent.Start.Position; offset++)
            {
                switch (snapshot[location.Position - offset - 1])
                {
                    case ' ':
                    case '\t':
                        continue;
                    default:
                        break;
                }
                break;
            }

            extensionSpan = new SnapshotSpan(snapshot, location.Position - offset, offset);
        }

        //public bool IsCompletionProvider { get { return node is ICompletionProvider; } }

        /// <summary>
        /// Parent node of the current node. For the topmost nodes returns null
        /// </summary>
        public Node Parent { get; private set; }

        /// <summary>
        /// Span covering the source the INode was created from
        /// </summary>
        public SnapshotSpan SnapshotSpan { get { return snapshotSpan; } }

        /// <summary>
        /// The extension span for the INode - is empty unless the node has code completion values
        /// if not empty covers all whitespace to the left of the node 
        /// </summary>
        public SnapshotSpan ExtensionSpan { get { return extensionSpan; } }

        /// <summary>
        /// Translates the NodeSnapshot to a newer snapshot
        /// </summary>
        /// <param name="snapshot"></param>
        public void TranslateTo(ITextSnapshot snapshot)
        {
            snapshotSpan = snapshotSpan.TranslateTo(snapshot, SpanTrackingMode.EdgeExclusive);
            extensionSpan = extensionSpan.TranslateTo(snapshot, SpanTrackingMode.EdgeExclusive);
            foreach (Node child in children)
                child.TranslateTo(snapshot);
        }

        /// <summary>
        /// Displays a diagnostic message in the error list window as well as in the output pane
        /// </summary>
        /// <param name="djangoDiagnostics"></param>
        /// <param name="filePath"></param>
        //public void ShowDiagnostics()
        //{
        //    if (node.ErrorMessage.Severity > 0)
        //    {
        //        ITextSnapshotLine line = snapshotSpan.Snapshot.GetLineFromPosition(node.Position);
        //        errorTask = new ErrorTask();
        //        errorTask.Document = Provider.Filename;
        //        errorTask.Line = line.LineNumber; // The task list does +1 before showing this number.
        //        errorTask.Column = node.Position - line.Extent.Start;// line.Start;
        //        errorTask.Text = node.ErrorMessage.Message;
        //        errorTask.Priority = TaskPriority.High;
        //        errorTask.Category = TaskCategory.CodeSense;
        //        errorTask.HierarchyItem = null;
        //        if (node.ErrorMessage.Severity == 1)
        //            errorTask.ErrorCategory = TaskErrorCategory.Warning;

        //        Provider.ShowDiagnostics(errorTask);
        //    }

        //    children.ForEach(child => child.ShowDiagnostics());
        //}

        //private ErrorTask errorTask;

        /// <summary>
        /// A list of child nodes
        /// </summary>
        public List<Node> Children { get { return children; } }

        #region INode Members

        //public string Description
        //{
        //    get { return node.Description; }
        //}

        //public Error ErrorMessage
        //{
        //    get { return node.ErrorMessage; }
        //}

        public int Length
        {
            get { return astnode.Span.Length; }
        }

        //public NodeType NodeType
        //{
        //    get { return node.NodeType; }
        //}

        public IEnumerable<AstNode> Nodes
        {
            get { return astnode.ChildNodes; }
        }

        public int Position
        {
            get { return astnode.Location.Position; }
        }

        //public virtual IEnumerable<string> Values
        //{
        //    get
        //    {
        //        var completion_provider = node as ICompletionValuesProvider;
        //        if (completion_provider == null)
        //            return new List<string>();
        //        return completion_provider.Values;
        //    }
        //}

        //public IParsingContext Context { get { return node.Context; } }

        #endregion

        #region IDisposable Members

        public void Dispose()
        {
            Dispose(true);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                //if (errorTask != null)
                //    Provider.RemoveDiagnostics(errorTask);
                children.ForEach(child => child.Dispose());
            }
        }

        #endregion
    }
}
